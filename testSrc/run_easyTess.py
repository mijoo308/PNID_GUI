# -*- coding: utf-8 -*-
"""easyocr

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/vistec-AI/colab/blob/master/easyocr.ipynb
"""

# show an image
import PIL
from PIL import ImageDraw, ImageFont, Image
import easyocr
import os
import cv2
import time
import testSrc.utils as cb
import numpy as np
import pytesseract

img_dir = "./data"
result_dir = './result'
date = time.localtime()
time_info = str(date.tm_year) + (str(date.tm_mon)).zfill(2) + \
            (str(date.tm_mday)).zfill(2) + '_' + (str(date.tm_hour)).zfill(2) + '.' \
            + (str(date.tm_min)).zfill(2) + '_'
result_dir_for_each_test = result_dir + '/' + time_info
os.mkdir(result_dir_for_each_test)

txt_result_dir_for_xml = result_dir_for_each_test + '/txtForXML'
if not os.path.isdir(txt_result_dir_for_xml):
    os.mkdir(txt_result_dir_for_xml)

# --------- Param    --------------------------------------------------

CALC_IOU = False

drawing_path = ''
CROP_SIZE = 2000
STRIDE_SIZE = 1000

IOU_THRESHOLD = 0

RESULT_BOX_COLOR = 'red'
RESULT_FONT_SIZE = 20

reader = easyocr.Reader(['en'])

OEM = 3
PSM = 6

TRAINEDDATA = 'eng'
# traineddata = 'real709'


# ----------------------------------------------------------------------

def draw_boxes(image, bounds, color=RESULT_BOX_COLOR, width=2):
    draw = ImageDraw.Draw(image)
    for bound in bounds:
        p0, p1, p2, p3 = bound[0]
        draw.line([*p0, *p1, *p2, *p3, *p0], fill=color, width=width)

    return image


def draw_merged_result(im, txt_path, outpath):  # new
    txt_file = open(txt_path, 'r', encoding='UTF8')
    lines = txt_file.readlines()
    img_name = os.path.basename(txt_path)
    img_name = str(img_name.split('.')[0])
    width = im.width
    height = im.height
    im = im.convert("RGB")
    newImage = Image.new(mode='RGB', size=(width, height), color=(255, 255, 255))  # 빈 도면

    for line in lines:
        Fdraw = ImageDraw.Draw(im)
        Edraw = ImageDraw.Draw(newImage)

        parsedBox = line.split('ㅣ')
        Bxmin = int(parsedBox[0])
        Bymin = int(parsedBox[1])
        Bxmax = int(parsedBox[2])
        Bymax = int(parsedBox[3])
        Tstring = parsedBox[4]
        orientation = int(parsedBox[5])

        Fdraw.line([(Bxmin, Bymin), (Bxmax, Bymin), (Bxmax, Bymax), (Bxmin, Bymax), (Bxmin, Bymin)],
                   fill=RESULT_BOX_COLOR, width=2)  # LTRB
        Edraw.line([(Bxmin, Bymin), (Bxmax, Bymin), (Bxmax, Bymax), (Bxmin, Bymax), (Bxmin, Bymin)],
                   fill=RESULT_BOX_COLOR, width=2)  # LTRB

        RnewImage = newImage.transpose(Image.ROTATE_270)
        Rdraw = ImageDraw.Draw(RnewImage)
        font = ImageFont.truetype("arial.ttf", RESULT_FONT_SIZE)

        if orientation == 90:
            Rdraw.text((height - Bymax, Bxmin), Tstring, font=font, fill='black', align='left')
            newImage = RnewImage.transpose(Image.ROTATE_90)

        else:
            Edraw.text((Bxmin, Bymin), Tstring, font=font, fill='black', align='left')

    im.save(os.path.join(outpath, img_name + "_boxResult.jpg"))
    newImage.save(os.path.join(outpath, img_name + "_txtResult.jpg"))


def write_chars(image, bounds):
    newImage = PIL.Image.new(mode='RGB', size=(image.width, image.height), color=(255, 255, 255))

    for bound in bounds:
        draw = ImageDraw.Draw(newImage)
        p0, p1, p2, p3 = bound[0]

        draw.line([*p0, *p1, *p2, *p3, *p0], fill=RESULT_BOX_COLOR, width=2)
        Bxmin = int(p0[0])
        Bymin = int(p0[1])
        Bxmax = int(p2[0])
        Bymax = int(p2[1])

        Tstring = bound[1]

        font = ImageFont.truetype("arial.ttf", RESULT_FONT_SIZE)
        if Bymax - Bymin > Bxmax - Bxmin:
            RnewImage = newImage.transpose(Image.ROTATE_270)
            Rdraw = ImageDraw.Draw(RnewImage)
            Rdraw.text((image.height - Bymax, Bxmin), Tstring, font=font, fill='black', align='left')
            newImage = RnewImage.transpose(Image.ROTATE_90)

        else:
            draw.text((Bxmin, Bymin), Tstring, font=font, fill='black', align='left')

    return newImage


def write_txt2(bounds, path):
    f = open(path, 'w')

    for bound in bounds:
        xmin = int(bound[0])  # int() for CLEval
        xmax = int(bound[1])
        ymin = int(bound[2])
        ymax = int(bound[3])

        data = str(xmin) + 'ㅣ' + str(ymin) + 'ㅣ' + str(xmax) + 'ㅣ' + str(ymax) + '\n'
        f.write(data)

    f.close()


def recognize_merged_data(read, merged_data_path, resizedIm, result_dir):
    f_read = open(merged_data_path, 'r')  # ..
    lines = f_read.readlines()
    f_read.close()

    imgname = str((os.path.basename(merged_data_path)).split('.')[0])
    finalFilePath = os.path.join(result_dir, imgname + "_resized_result.txt")
    f_write = open(finalFilePath, 'w')

    test = 0
    for line in lines:  # per string
        test += 1
        Bbox_data = line.split('ㅣ')
        xmin = int(Bbox_data[0])
        ymin = int(Bbox_data[1])
        xmax = int(Bbox_data[2])
        ymax = int(Bbox_data[3])
        orientation = 0

        croppedImg = resizedIm[ymin:ymax, xmin:xmax]
        result = read.recognize(croppedImg)
        result_string = result[0][1]  # -> string
        result_confidence = result[0][2]  # ->confidence

        objectWidth = xmax - xmin
        objectHeight = ymax - ymin
        if objectHeight > objectWidth:


            tmatrix = np.float32([[1, 0, objectHeight], [0, 1, 0]])  # matrix for transfer
            rmatrix = cv2.getRotationMatrix2D((objectHeight, 0), -90, 1)  # matrix for rotate
            rotatedImg = cv2.warpAffine(croppedImg, tmatrix, (objectHeight + objectWidth, objectHeight))
            rotatedImg = cv2.warpAffine(rotatedImg, rmatrix, (objectHeight, objectWidth))

            result2 = read.recognize(rotatedImg)

            result2_string = result2[0][1]
            orientation = 90
            result_string = result2_string

        data = str(xmin) + "ㅣ" + str(ymin) + "ㅣ" + str(xmax) + "ㅣ" + str(ymax) + "ㅣ" + result_string + "ㅣ" + str(
            orientation) + "\n"
        f_write.write(data)
    f_write.close()


def RecognizeEasyBoxes(easybox_path, resized_im, result_root):
    f_read = open(easybox_path, 'r')
    lines = f_read.readlines()
    f_read.close()

    imgname = str((os.path.basename(easybox_path)).split('.')[0])
    finalFilePath = os.path.join(result_root, imgname + "_origin_result.txt") ###### resized_result.txt
    f_write = open(finalFilePath, 'w',  encoding='UTF8')

    for line in lines:  # per string
        Bbox_data = line.split('ㅣ')
        xmin = int(Bbox_data[0])
        ymin = int(Bbox_data[1])
        xmax = int(Bbox_data[2])
        ymax = int(Bbox_data[3])
        orientation = 0

        croppedImg = resized_im[ymin:ymax, xmin:xmax]
        objectHeight, objectWidth, objectChannel = croppedImg.shape

         # 결과
        confidence = 0
        result_string = ''

        if objectHeight > 2 * objectWidth:  # width보다 두배 이상 크면 그냥 세로문자열로 취급

            orientation = 90
            tmatrix = np.float32([[1, 0, objectHeight], [0, 1, 0]])  # matrix for transfer
            rmatrix = cv2.getRotationMatrix2D((objectHeight, 0), -90, 1)  # matrix for rotate
            rotatedImg = cv2.warpAffine(croppedImg, tmatrix, (objectHeight + objectWidth, objectHeight))
            rotatedImg = cv2.warpAffine(rotatedImg, rmatrix, (objectHeight, objectWidth))

            croppedImg = rotatedImg

            ocr_result = pytesseract.image_to_data(croppedImg,
                                                   lang=TRAINEDDATA,
                                                   config='--oem ' + str(OEM) + ' --psm ' + str(PSM))
            result_to_list = ocr_result.split('\n')
            for result in result_to_list:
                res = result.split('\t')
                if res[0] == '5':
                    confidence = int(res[-2])
                    result_string = result_string + res[-1]

        else:
            ocr_result1 = pytesseract.image_to_data(croppedImg,
                                                    lang=TRAINEDDATA,
                                                    config='--oem ' + str(OEM) + ' --psm ' + str(PSM))
            confidence = 0
            result_string = ''

            result_to_list = ocr_result1.split('\n')
            for result in result_to_list:
                res = result.split('\t')
                if res[0] == '5':
                    confidence = int(res[-2])
                    result_string = result_string + res[-1]

            if objectHeight > objectWidth:  # width보다 큰데 두배 이상보단 작으면  확인해봄
                tmatrix = np.float32([[1, 0, objectHeight], [0, 1, 0]])  # matrix for transfer
                rmatrix = cv2.getRotationMatrix2D((objectHeight, 0), -90, 1)  # matrix for rotate
                rotatedImg = cv2.warpAffine(croppedImg, tmatrix, (objectHeight + objectWidth, objectHeight))
                rotatedImg = cv2.warpAffine(rotatedImg, rmatrix, (objectHeight, objectWidth))

                croppedImg = rotatedImg

                ocr_result2 = pytesseract.image_to_data(croppedImg,
                                                        lang=TRAINEDDATA,
                                                        config='--oem ' + str(OEM) + ' --psm ' + str(PSM))
                confidence2 = 0
                result_string2 = ''
                result_to_list2 = ocr_result2.split('\n')
                for result in result_to_list2:
                    res = result.split('\t')
                    if res[0] == '5':
                        confidence2 = int(res[-2])
                        result_string2 = result_string2 + res[-1]
                    if confidence2 > confidence:
                        result_string = result_string2
                        orientation = 90
                        confidence = confidence2  ### 1213


        data = str(xmin) + 'ㅣ' + str(ymin) + 'ㅣ' + str(xmax) + 'ㅣ' + str(ymax) + 'ㅣ' + result_string + 'ㅣ' + str(
            orientation) + 'ㅣ' + str(int(confidence)) + "\n"
        f_write.write(data)

    f_write.close()

# -------- main ----------------------------------------------------------------------------
start = time.time()

# set cb parameter
cb.sizeForCrop = CROP_SIZE
cb.sizeForStride = STRIDE_SIZE

path_for_img_size = ''
for file in os.listdir(img_dir):
    if file.endswith('.jpg') or file.endswith('.png'):
            path_for_img_size = os.path.join(img_dir, file)
            break

im = cv2.imread(path_for_img_size)
DRAWING_HEIGHT = im.shape[0]  # coordinate transform 이랑 xml 만들기 위해
DRAWING_WIDTH = im.shape[1]

cb.originWidth = DRAWING_WIDTH
cb.originHeight = DRAWING_HEIGHT


original_img_list = []
# cb.make_rotated_img(img_dir)
cb.crop_big_image(result_dir_for_each_test, img_dir)  # data Crop
resized_img_list = []

subTxtResultDir_List = []  # to merge the result

print("Detecting...")
for foldername in os.listdir(img_dir):  # ./data
    subImgDir = os.path.join(img_dir, foldername)

    if os.path.isdir(subImgDir):

        subTxtResultDir = os.path.join(result_dir_for_each_test, foldername + '_txt')
        subImgResultDir = os.path.join(result_dir_for_each_test, foldername)
        subTxtResultDir_List.append(subTxtResultDir)  # ['KNU-A-22300-001-01_txt', KNU-A-22300-001-03_txt']  _txt 폴더들

        os.mkdir(subTxtResultDir)
        # os.mkdir(subImgResultDir)

        for file in os.listdir(subImgDir):  # per subImg


            fullCropImgFilePath = os.path.join(subImgDir, file)
            cropImgName = os.path.basename(fullCropImgFilePath)
            cropImgName = str(cropImgName.split('.')[0])
            fullCropTxtFilePath = os.path.join(subTxtResultDir, cropImgName + ".txt")

            im = PIL.Image.open(fullCropImgFilePath)

            # Doing OCR. Get bounding boxes.
            # bounds = reader.readtext(fullCropImgFilePath)
            horizon_list, free_list = reader.detect(fullCropImgFilePath)
            write_txt2(horizon_list, fullCropTxtFilePath)

    else:  # 그냥 도면 원본파일
        original_img_list.append(subImgDir)
        im = cv2.imread(subImgDir)
        # resizedIm = cv2.resize(im, dsize=(resizedWidth, resizedHeight))
        resized_img_list.append(im)


# --- merge ---
print("Merging detected boxes...")
for subTxtResultDir in subTxtResultDir_List:
    cb.merge_result(subTxtResultDir, result_dir_for_each_test)

# -- recognize with Tesseract----------
print("Recognizing...")
merged_text_list = []
for file in os.listdir(result_dir_for_each_test):
    if file.endswith(".txt"):
        merged_text_list.append(os.path.join(result_dir_for_each_test, file))

for merged_text_path, resizedIm in zip(merged_text_list, resized_img_list):
    RecognizeEasyBoxes(merged_text_path, resizedIm, result_dir_for_each_test)


#--------------- save result with IOU & confidence --------------

if CALC_IOU:
    origin_result_list = []  # ['KNU-A-22300-001-04-rotated_origin_result.txt']
    rotated_result_list = []  # ['KNU-A-22300-001-04_origin_result.txt']

    for file in os.listdir(result_dir_for_each_test):
        if file.endswith("origin_result.txt"):
            if file.endswith("rotated_origin_result.txt"):
                rotated_result_list.append(str(os.path.join(result_dir_for_each_test, file)))
            else:
                origin_result_list.append(str(os.path.join(result_dir_for_each_test, file)))

    for origin_result, rotated_result in zip(origin_result_list, rotated_result_list):  # per drawing
        o_read = open(origin_result, 'r', encoding='UTF8')
        r_read = open(rotated_result, 'r', encoding='UTF8')
        o_lines = o_read.readlines()
        r_lines = r_read.readlines()
        o_read.close()
        r_read.close()

        intersect_txt_name = str(os.path.basename(origin_result).split('_')[0]) + '_final_result.txt'
        intersect_txt_path = os.path.join(result_dir_for_each_test, intersect_txt_name)
        w_file = open(intersect_txt_path, 'w', encoding='UTF8')
        # origin_result

        origin_box_result = []
        origin_text_result = []
        for line in o_lines:
            result = line.split('ㅣ')
            print(result)
            origin_box_result.append([int(result[0]), int(result[1]), int(result[2]), int(result[3]),
                                      int(result[6])])  # xmin, ymin, xmax, ymax, confidence
            origin_text_result.append(str(result[4]))

        rotated_box_result = []
        rotated_text_result = []
        for line in r_lines:
            result = line.split('ㅣ')
            rotated_box_result.append([int(result[0]), int(result[1]), int(result[2]), int(result[3]),
                                       int(result[6])])  # xmin, ymin, xmax, ymax, confidence
            rotated_text_result.append(str(result[4]))

        for resultText, resultBox in zip(origin_text_result, origin_box_result):
            result = cb.IOU_fast(rotated_box_result, rotated_text_result, resultBox, resultText, IOU_THRESHOLD)

            if result != None:
                w_file.write(result)
                k = result

        w_file.close()



# -- visualize result ----
img_path_list = []
for file in os.listdir(result_dir_for_each_test):
    if file.endswith(".jpg"):
        if not file.endswith("rotated.jpg"):
            img_path_list.append(os.path.join(result_dir_for_each_test, file))

# txt_result_list = []
# for file in os.listdir(result_dir_for_each_test):
#     if file.endswith("resized_result.txt"):
#         txt_result_list.append(os.path.join(result_dir_for_each_test, file))
#
# for txt_path in txt_result_list:
#     cb.return_to_original_size(exceptXpos, exceptYpos, txt_path, result_dir_for_each_test)

txt_origin_list = []
txt_iou_result_list = []

for file in os.listdir(result_dir_for_each_test):
    if file.endswith("origin_result.txt"):
        txt_origin_list.append(os.path.join(result_dir_for_each_test, file))

if CALC_IOU:
    for file in os.listdir(result_dir_for_each_test):
        if file.endswith("final_result.txt"):
            txt_iou_result_list.append(str(os.path.join(result_dir_for_each_test, file)))


# except
if CALC_IOU:
    for txt_path in txt_iou_result_list:
        # cb.except_selected_pos(padding_pos, infobox_pos, txt_path, result_dir_for_each_test)
        cb.except_selected_pos(txt_path, result_dir_for_each_test)

for txt_path in txt_origin_list:
    # cb.except_selected_pos(padding_pos, infobox_pos, txt_path, result_dir_for_each_test)
    cb.except_selected_pos(txt_path, result_dir_for_each_test)


# txt_origin_list = []
# for file in os.listdir(result_dir_for_each_test):
#     if file.endswith("origin_result.txt"):
#         txt_origin_list.append(str(os.path.join(result_dir_for_each_test, file)))

jpg_origin_list = []
for file in os.listdir(result_dir_for_each_test):
    if file.endswith(".jpg"):
        jpg_origin_list.append(str(os.path.join(result_dir_for_each_test, file)))

print("Drawing result...")
for txt_path, img_path in zip(txt_iou_result_list, img_path_list):
    im = Image.open(img_path)
    draw_merged_result(im, txt_path, result_dir_for_each_test)

for txt_path, img_path in zip(txt_origin_list, jpg_origin_list):
    im = Image.open(img_path)
    draw_merged_result(im, txt_path, result_dir_for_each_test)



# -- make xml----
print("Making xml...")
cb.makeXML(DRAWING_WIDTH, DRAWING_HEIGHT, result_dir_for_each_test, img_dir)

print("time: ", time.time() - start)


